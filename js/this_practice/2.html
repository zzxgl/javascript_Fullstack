<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
  <iframe src="www.baidu.com" frameborder="0"></iframe>
  <iframe src="" frameborder="0"></iframe>
  <script>
    function fn() {
      console.log(this.length)
    }
    // fn()  //  this 指向window   window.length => iframe节点的个数
    var bar = {
      length:5,
      fn1:function() {
        // console.log(this)  // this === bar1
        fn()
        arguments[0]() //每一个普通函数(箭头函数没有)都可以用的对象  对象里面有这个函数的所有参数  类数组对象
        // console.log(this.length)
      }
    }
    var bar1 = {
      length:6
    }
    const res = bar.fn1.bind(bar1)
    // bind()不调用 返回绑定this后的函数
    res(fn,123456,123) //2,3 2=全局下fn()指向window 3=> fn() this指向arguments
    // arguments ={
    //   0:fn,
    //   1:123456,
    //   2：123,
    //   length:3
    // }

    // obj.fn<call/apply/bind<new


    // aruments
    // foo(1,2,3)
    // function foo() {
    //   console.log(arguments)
    //   console.log(typeof arguments.map)// undefined
    // //   将类数组转为数组
    //   let arr= Array.from(arguments)
    // //   借用数组的slice方法 slice没有传入参数代表从第一项截取到最后一项
    //   console.log(arr.map)
    // }
    // console.log(document.querySelectorAll('iframe'))


    // 借用  call的作用是将方法的调用时 作用域指向p2,
    // function Person (age)　{
    //   this.age = age
    // }
    // Person.prototype.reduceAge = function () {
    //   return this.age - 10
    // }
    // var p = new Person(28)
    // console.log(p.reduceAge())
    // var p2 = {age:'30'}
    // console.log(Person.prototype.reduceAge.call(p2))
  </script>    
</body>
</html>